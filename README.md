# Отчет по домашней работе №4
## Дисциплина: Конструирование программного обеспечения
## Тема: Асинхронное межсервисное взаимодействие в микросервисной архитектуре

**Студент:** Нурмагомедов Радамир Ренатович
**Группа:** БПИ-246

---

### 1. Постановка задачи
Целью работы была разработка двух ключевых микросервисов для интернет-магазина «Gozon»: **Orders Service** (управление заказами) и **Payments Service** (управление финансами пользователей). Основное требование — реализация надежного асинхронного взаимодействия с использованием брокера сообщений, обеспечивающего гарантии доставки и обработки сообщений (*effectively exactly once*).

---

### 2. Архитектура системы

В соответствии с рекомендациями архитектурного комитета, система была разделена на независимые компоненты:

*   **API Gateway (YARP):** Прокси-сервер на порту `8080`, который маршрутизирует внешние HTTP-запросы к соответствующим сервисам. 
*   **Orders Service:** Владеет базой данных заказов. Реализует CRUD операции и инициирует процесс оплаты.
*   **Payments Service:** Владеет базой данных счетов. Отвечает за проверку баланса и списание средств.
*   **RabbitMQ:** Брокер сообщений, через который передаются события `OrderCreatedEvent` и `PaymentResultEvent`.

---

### 3. Реализация ключевых паттернов (Требования на 8 баллов)

#### 3.1. Transactional Outbox (Гарантия доставки)
В обоих сервисах реализован паттерн **Outbox**. Вместо прямой отправки сообщения в RabbitMQ во время HTTP-запроса, событие сохраняется в таблицу `OutboxMessages` в одной транзакции с бизнес-данными (заказом или списанием). 
*   Специальный фоновый процесс `OutboxPublisherService` периодически опрашивает базу и пересылает сообщения в RabbitMQ. Это гарантирует, что сообщение не потеряется, даже если брокер был временно недоступен.

#### 3.2. Transactional Inbox (Идемпотентность)
Для исключения повторного списания денег при дублировании сообщений в **Payments Service** реализован **Transactional Inbox**:
*   При получении заказа его ID сохраняется в таблицу `InboxMessages`. 
*   Если сообщение с таким ID приходит повторно, сервис обнаруживает запись в БД и игнорирует обработку, обеспечивая семантику *exactly-once*.

#### 3.3. Compare and Swap / CAS (Атомарность баланса)
Для защиты от «состояния гонки» (race condition) при параллельных запросах к одному счету использован механизм оптимистичных блокировок. В модели `Account` настроено поле версии с атрибутом `[ConcurrencyCheck]`. При обновлении баланса Entity Framework проверяет соответствие версии, реализуя атомарную инструкцию на уровне БД.

---

### 4. Описание пользовательского сценария оплаты

1.  **Пользователь** отправляет запрос на создание заказа в `Orders Service`.
2.  **Orders Service** сохраняет заказ (статус `NEW`) и запись в `Outbox` в рамках одной транзакции.
3.  **Outbox Worker** отправляет событие `OrderCreatedEvent` в очередь RabbitMQ.
4.  **Payments Service** (Consumer) считывает событие, проверяет `Inbox` на дубликаты.
5.  **Payments Service** списывает деньги (используя CAS), сохраняет статус в `Inbox` и результат в свой `Outbox`.
6.  **Payments Outbox Worker** отправляет `PaymentResultEvent` обратно.
7.  **Orders Service** получает результат и обновляет статус заказа на `FINISHED` (успех) или `CANCELLED` (недостаточно средств).

---

### 5. Инфраструктура и запуск

Проект полностью контейнеризирован с помощью **Docker**.
*   Для развертывания используется `docker-compose.yml`, который поднимает 6 контейнеров: `gateway`, `orders-api`, `payments-api`, `orders-db`, `payments-db` и `rabbitmq`.
*   Базы данных инициализируются автоматически при старте приложений через `context.Database.EnsureCreated()`.

**Команда для запуска:**
```bash
docker-compose up --build
```

### Инфраструктура и мониторинг
После запуска системы через Docker Compose, доступны следующие интерфейсы для мониторинга:
*   **API Gateway:** `http://localhost:8080` — основная точка входа для запросов.
*   **RabbitMQ Management UI:** `http://localhost:15672`
    *   **Логин:** `guest`
    *   **Пароль:** `guest`
    *   Через этот интерфейс можно отслеживать состояние очередей `order_created` и `payment_results_queue`, а также количество активных потребителей (Consumers).

## 6. Результаты тестирования

Тестирование работоспособности системы проводилось путем отправки HTTP-запросов через **API Gateway (порт 8080)**. Мониторинг асинхронных процессов осуществлялся через логи Docker-контейнеров и веб-интерфейс RabbitMQ Management.

### Кейс 1: Создание счета и пополнение баланса
Проверена базовая функциональность сервиса платежей и работа механизма **CAS** (Compare and Swap) при обновлении баланса.

*   **Запрос на создание счета:** `POST /api/payments/account` с телом `{"userId": "hse_student_2025"}`.
    *   *Результат:* 200 OK. В базе данных `payments_db` создана запись с балансом 0.00 и начальным значением версии.
*   **Запрос на пополнение:** `POST /api/payments/account/topup` с телом `{"userId": "hse_student_2025", "amount": 1000}`.
    *   *Лог Payments Service:* `info: Payments.Controllers.PaymentsController[0] Счет пользователя hse_student_2025 пополнен на 1000. Новая версия CAS сгенерирована.`

### Кейс 2: Успешная цепочка оплаты (Асинхронный сценарий)
Проверено полное взаимодействие сервисов через брокер сообщений по схеме: *Orders -> RabbitMQ -> Payments -> RabbitMQ -> Orders*.

1.  **Создание заказа:** `POST /api/orders` на 400 у.е.
    *   *Мгновенный ответ:* Статус `NEW` (заказ сохранен в БД и поставлен в Outbox).
2.  **Работа воркеров:**
    *   `OutboxPublisher` (Orders) отправил событие `OrderCreated` в очередь.
    *   `OrderCreatedConsumer` (Payments) считал событие и вызвал логику списания.
    *   `PaymentService` списал 400 у.е. и подтвердил операцию через свой Outbox.
3.  **Проверка итога:** Через 2 секунды запрос `GET /api/orders/{id}` вернул статус **`FINISHED`**. Баланс пользователя в базе стал равен **600**.

### Кейс 3: Отказ в оплате (Недостаточно средств)
Проверена обработка негативного сценария и корректность обратной связи.

1.  **Запрос:** Создание заказа на сумму 5000 у.е. (при текущем балансе 600).
2.  **Обработка:** Сервис платежей зафиксировал нехватку средств, добавил ID сообщения в Inbox (чтобы не обрабатывать повторно) и отправил в RabbitMQ уведомление о неудаче.
3.  **Результат:** Сервис заказов считал ответ и перевел статус заказа в **`CANCELLED`**.

### Кейс 4: Проверка идемпотентности (Transactional Inbox)
Проверено выполнение требования *effectively exactly once* (обработка сообщения не более одного раза).

*   **Действие:** Через панель RabbitMQ в очередь `order_created` было вручную отправлено дублирующее сообщение с ID заказа, который уже был успешно оплачен в Кейсе 2.
*   **Лог Payments Service:**
    ```text
    warn: Payments.Services.PaymentService[0]
          Заказ 497f6eca-6276-4993-bfeb-53cbbbba6f08 уже был обработан. Игнорируем дубликат.
    ```
*   **Результат:** Благодаря паттерну **Transactional Inbox**, система определила дубликат по таблице `InboxMessages`. Повторного списания денег не произошло, целостность данных сохранена.

---

## Заключение

В ходе выполнения домашней работы были успешно реализованы механизмы надежного асинхронного взаимодействия микросервисов в рамках распределенной системы.

1.  **Гарантия доставки:** Использование паттерна **Transactional Outbox** позволило гарантировать сохранение и последующую отправку событий даже в случае кратковременного падения брокера сообщений.
2.  **Идемпотентность:** Реализация **Transactional Inbox** обеспечила защиту от повторного списания средств, что является критически важным для финансовых модулей системы (семантика *exactly-once*).
3.  **Атомарность:** Применение механизма **CAS** на уровне базы данных защитило счета пользователей от коллизий при параллельных запросах (race conditions).
4.  **Масштабируемость и контейнеризация:** Вся инфраструктура (сервисы, базы данных, брокер) упакована в **Docker** и разворачивается одной командой через `docker-compose`, что обеспечивает идентичность среды разработки и эксплуатации.

Разработанное решение полностью соответствует техническому заданию и демонстрирует применение современных паттернов проектирования микросервисной архитектуры.
